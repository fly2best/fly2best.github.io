---
layout: post
title: "c traps and pitfalls 笔记"
description: "笔记"
category: tech
tags: [c]
---

{% include JB/setup %}

今天把 c ctraps and pitfalls 读了一遍。

这本书的部分内容已经过气了，但是总体来说还是不错的。

总结一下引起我注意的地方:

*  词法分析时的"大嘴法"

    "大嘴法", 在确定一个token的时候，会读取尽量多的字符。

    如: a-----b 等价于 ((a--)--)-b

    ps: a-----b是编译通不过的，因为--操作符的的操作数须是左值。

*  函数指针

    当函数的返回值是个函数指针时，函数的声明看起来总是有点怪, 这次会过头来看，发现一种好理解的方法。

    如: int (*fun_ret_funptr(void))(int)

    这是一个函数，返回了一个函数指针, 指向了一个参数和返回值均为int的函数。

    如果把fun_ret_funptr(void) 替换成... 转换成:

        int (* ... )(int)

    我们知道里面哪个东西的类型是个函数指针，那函数的类型是个函数指针的是什么意思呢？
    其实就是其返回值的类型。
    (函数指针 于 指针函数?)

    越来越觉得把概念弄清楚是极其重要的事情。

*   *p++ 的运算顺序是结合性决定的

    运算符的有两个性质需要搞清楚，优先级和结合性。

    *和++ 运算法的优先级 是相同的，但是都是右结合性(有两个时，先算右边的)，所以运行顺序是先++,然后再\*

    以前我是怎么记住的呢。。。。我也不知道，反正我是记住了。。。。

    说到运算符的运算符，还有两个小东西引起了注意。

    *   ">>" 运算符

        -   优先级比关系运算高，比算数运算低
            so:
                a >> 1 + 2 > 8 <==> ( a >> (1 + 2) ) > 8

        -   没有>>= 运算符
            先前写程序的出错过，这个看到的运算符的时候又想了起来。

    *   运算符的求值顺序

        有4个运算运算符的顺序是确定的，其他的运算符不确定.

        这四个分别是 &&，||, ?: 和逗号运算符。

        A && B, 先求A, 如果A为真，再对B求值，否则不对B求值。

        A || B, 先求A, 如果A为假，再对B求值，否则不对B求值。

        A ? B: C, 先求A， 如果A为真，则对B求值，否则对C求值。

        A, B, C,  先求A, 再求B，再求C。

*   文件读写中的一些问题

    这个平时用的不多.

    fread 和 fwrite 之间需要 fseek。

    查了一下: fflush or a file-positioning function must be called between a read and a write or vice versa.

    所以调用flush也是可以的.

*   不使用sizeof,如何确定int类型大小

    可以 0xff, 赋值给int，然后左移8位，什么时候变成负数了, 就知道int的大小了。

    不过着依赖于负数的最高为1，我不知道有没有负数最高位不是1的，但是着确实依赖了整数的编码.

    我在网上看到另外一种方法，用指针，赞一个:

        int p[2];
        printf("sizeof(int)=%d\n", (unsigned)(p + 1) - (unsigned)p);

*   栈的增长方向是硬件决定的

    看可变参数的时候我想起了栈的增长方向, 我想这是操作系统决定的呢？还是硬件。

    是硬件，学x86的汇编时，讲了push是esp减2, pop是esp加2

    嗯，我当时学的是16位的汇编。

    那怎么确定栈的增长方向呢？

    wget 使用了一个利用函数调用使用了栈和局部变量，巧妙的探测了栈的增长方向。

    至于获取栈的方向有什么用？

    在处理可变参数的时候会用到.

    如何根据第一个参数的地址确定下一个参数的地址呢，我们需要知道栈的方向.

    wget获取栈的方向干什么? 我也不知道。。。

我怕脑袋不好使,就整理了一下。

