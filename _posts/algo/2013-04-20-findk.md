---
layout: post
title: "查找第k大数"
description: ""
category: algorithm
tags: [algo]
---
{% include JB/setup %}


已知一个数组, 元素是可以互相比较的, 求第k大数, 及排序后下标为k的数.
如1, 1, 2, 第2数为1, 第3大数为2.

n比较小
======

朴素的方法
----------
最朴素的想法, 排序, 然后直接求出第k大数.
时间复杂度, O(nlogn), 空间复杂度O(n).

paritition
----------

如果借助partition, 则可以在平均O(n)的时间复杂, O(n)的空间复杂内解决问题.

证明:

设T(n)为在n个数中找第k大数的平均时间复杂度.

则T(n) <= T(3n/4) + O(n).

因为经过平均两次partition, 数组的长度会降为以前的3/4.

如果选中的v在[1/4, 3/4]中, 则数组长度至多为以前的3/4, v的被选中的概率是1/2, 平均两次, 就可以选中一次.

则

    T(n) <= T(3/4 * n) + O(n)
         <= T((3/4)^2 * n) + O(3/4 * n) + O(n)
         <= T((3/4)^3 * n) + (3/4)^2 * n + O(3/4 * n) + O(n)
         <= ....
         <= T((3/4)^k * n) + (3/4)^(k-1) * n + (3/4)^2 * n + O(3/4 * n) + O(n)

        (3/4)^k * n =1时终止.

         = 1 + O(n * (1 + 3/4 + (3/4)^2 + (3/4)^3 + ... + (3/4)^(k-1))
         = 1 + O(4n * ((1-(3/4)^k)))
         = O(n)

因此T(n) <= O(n), 因此T(n) 是O(n)的.
空间复杂度是O(n)的.

n非常大, k比较小
================

如果n非常大, 如10^10, 没办法全部放进内存, 就没办法直接用partition的方法.

因为k比较小, 可以在内存中维护一个k个数的大顶堆.
扫描数组, 如果内存中不还没有装够k个数，直接插入堆;
否则, 把当前元素和堆顶的元素比较,如果比较小于, 删除堆顶元素, 插入当前元素;
否则, 如果有下一元素，考虑下一个元素;
否则, 结束;

堆顶的元素即为第k大数.

因为堆取堆顶元素是O(1),插入是O(logk), 总共n次, so时间负责度是O(nlogk).

n大, k也大
==========

如果k也非常大,  没办法全部放入内存.
假设内存可以放m个元素.
那就来 celing[k/m] 次, 第一次前m大数;
第二次, 接着在剩下的数中找前m大数.
直到找到了第k大数.

时间复杂度为O(celing(k/m) * log(m) * n)

参考资料:

1.  Algorithms, chapter2.4 
2.  剑指offer, 面试题30 
3.  海量数据寻找中位数, http://blog.csdn.net/tianmo2010/article/details/7962690 
