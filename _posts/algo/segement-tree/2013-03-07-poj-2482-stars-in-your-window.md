---
layout: post
title: "poj 2482 stars in your window"
description: "解题报告"
category: algorithm
tags: [oj, algo, data structure]
---
{% include JB/setup %}


这道题目, 很奇葩.
整个题目的一大部分，是一份情书, e文写的，不过文笔非常不错.
八卦完毕...
<http://poj.org/problem?id=2482>   
题目大意:
很多点, 不同的权值; 一个矩形, 可以移动，不可以旋转;
怎么用矩形覆盖权值最大的一组点(不包括边界)   

做这个题目之前，我先做了poj2352, 那个题目... 不是我自己想处来的。

不过这个题目, 我受到上一题目的启发.

我们可以按块处理这些点.

方法:

1.  如果把点排序, 按点的y座标升序排列, 如果y相同, 按照x的升序排列.
2.  从第一点开始,处理高度差在H内的点, 求出最大的权值.
3.  如果还有其他点,删除最下面的一层点, 加入下一层点, 重复过程2;
    否则终止，输出最大值.   
    ps: 层就是y座标, 因为我们已经按y座标排序, 从头开始扫描就行.

重点在第2步.
怎么求矩形内的最大值呢?

刚开始我是这么做的:
枚举了W-1 能覆盖的最大区间，然后求出区间内权值和.
求权值和方法, 使用的线段树, 对区间进行了离散化处理, 因为x的范围比点的个数要大的多.
线段树, 结点保存了某个区间上的,权值. 权值在点插入和删除的时候更新.

这样权值和可以在O(log(n))时间,求出, n 为点的个数.
我枚举O(n)次, 每次O(log(n)), 时间就是O(nlog(n)).
第2步执行了O(n)次, 则时间复杂度是O(n^2 log(n)).

排序O(nlogn), 每个结点插入一次，删除一次共O(nlogn), 总时间复杂度就是O(n^2 log(n)).

这个题目的时间限制是1s, n 最大为10^4.   
因此时间复杂度, 是10^9数量级上, 时间限制为1s, 铁定TLE, 我不死心，看了这道题的status, TLE的不多, 过的人最快的也在50ms以内.
我就试了试, 果断悲剧.... TLE的不多，我却是其中一个.......

我知道自己的第2步挫了。google了一下，看别人的解题报告.

不少人是这么做的.

1.  把一个点拆成两个(x, y, brightness) 分成 (x + W, y, -brightness)
2.  对点进行排序, 按照x的座标递增, 如果x相同, brightness为负数优先.
3.  按照x的递增的顺序插入点. 插入点的时候, 加入向线段树加入区间 (y, y + H - 1), 权值为对应点的权值.
    相当于把(x, y), (x, y + H -1) 投影到y轴上,权值相加.
    区间最大值就是, 能覆盖的最多权值和.
    然后根结点的权值就是,就是当前的矩形能框的最大权值. 更新最大权值，直到遍历所有的点.   

怎么想的呢?

1.  通过处理,两个相聚差大于等于W的点不会被同时考虑, 因为当x越界的时候, 其对应的点就会被加入线段树, 抵消其权值.
2.  因此可以把点映射到Y轴上, 转化为定长线段, 能覆盖的最大值和问题.
3.  线段能覆盖的最大点权和, 可以转化为求区间最大值问题. 见[定长点段最多覆盖点数及其扩展问题][2].

看个例子:
    input:
    3 3 4
    1 2 1
    2 1 1
    3 4 1
    output: 3
过程
加入线段[2, 5], [1, 4], [4, 7].   
那么最大的应该是[4,4]所在的区间, 因为同时有3线段同时覆盖.

       ------------------
                |
                |
    6  ------------------
        |       |
    5  ------------------
        |   |   |
    4  ------------------
        |   |
        |   |
    2  ------------------
            |
    1  ------------------
    y/x 1   2   3


这个转化的思想很巧妙.
把覆盖的最大权值和, 转化了求区间最大值.

因此, 仿照这个思路, 我刚开始已经对X进行了离散化, 就把线段投影到了x轴上.  求了区间最大和.

一交Wrong Answer, 想起Discuss上说的溢出, 把 int,全换成long long, AC.   
代码在[这里][1].

因为题目中的极富passion的情书，这个巧妙的转化思路, 是为一记.

参考了:   
<http://blog.sina.com.cn/s/blog_691ce2b701018ewr.html>   
<http://blog.csdn.net/zxy_snow/article/details/6749489>

[1]: https://github.com/fly2best/oj/blob/master/poj/segment_tree/stars_in_your_window_2482_v3.cc
[2]: /algorithm/2013/03/15/segement-cover-point/
